<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>cadmus documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	      <link rel="stylesheet" href="../styles/style.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">cadmus documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">












<ol class="breadcrumb">
  <li>Interfaces</li>
  <li>SelectedRange</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>libs/core/src/lib/services/text-layer.service.ts</code>
        </p>

            <p class="comment">
                <h3>Description</h3>
            </p>
            <p class="comment">
                <p>The selected range of text. This reflects rangy&#39;s Range useful properties;
in fact, you can just pass a Range to any method requiring this parameter type,
but this adds a level of indirection useful in testing.</p>

            </p>


        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#commonAncestorContainer">commonAncestorContainer</a>
                                </li>
                                <li>
                                        <a href="#endContainer">endContainer</a>
                                </li>
                                <li>
                                        <a href="#endOffset">endOffset</a>
                                </li>
                                <li>
                                        <a href="#startContainer">startContainer</a>
                                </li>
                                <li>
                                        <a href="#startOffset">startOffset</a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="commonAncestorContainer"></a>
                                        <span class="name"><b>commonAncestorContainer</b><a href="#commonAncestorContainer"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>commonAncestorContainer:     <code>Node</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Node</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="endContainer"></a>
                                        <span class="name"><b>endContainer</b><a href="#endContainer"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>endContainer:     <code>Node</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Node</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="endOffset"></a>
                                        <span class="name"><b>endOffset</b><a href="#endOffset"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>endOffset:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="startContainer"></a>
                                        <span class="name"><b>startContainer</b><a href="#startContainer"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>startContainer:     <code>Node</code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>    <code>Node</code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="startOffset"></a>
                                        <span class="name"><b>startOffset</b><a href="#startOffset"><span class="icon ion-ios-link"></span></a></span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>startOffset:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Injectable } from &#x27;@angular/core&#x27;;
import { TokenPoint } from &#x27;../token-point&#x27;;
import { TokenLocation } from &#x27;../token-location&#x27;;
import { TokenTextLayerLine, TextCoords } from &#x27;../models&#x27;;
import * as rangy from &#x27;rangy&#x27;;

// requires rangy:
// npm install --save rangy
// npm install --save @types/rangy

/**
 * The selected range of text. This reflects rangy&#x27;s Range useful properties;
 * in fact, you can just pass a Range to any method requiring this parameter type,
 * but this adds a level of indirection useful in testing.
 */
export interface SelectedRange {
  commonAncestorContainer: Node;
  startContainer: Node;
  startOffset: number;
  endContainer: Node;
  endOffset: number;
}

@Injectable({ providedIn: &#x27;root&#x27; })
export class TextLayerService {
  private readonly _wsRegex : RegExp;

  constructor() {
    this._wsRegex &#x3D; new RegExp(&#x27;^\\s$&#x27;, &#x27;g&#x27;);
  }

  private isWhitespace(c: string): boolean {
    if (!c) {
      return false;
    }
    if (c.length !&#x3D;&#x3D; 1) {
      c &#x3D; c.charAt(0);
    }
    return this._wsRegex.test(c);
  }

  /**
   * Extract the lines with their tokens from the specified text.
   * @param text the source text.
   * @returns lines.
   */
  public getLines(text: string): TokenTextLayerLine[] {
    const results: TokenTextLayerLine[] &#x3D; [];
    if (!text) {
      return results;
    }
    const lines &#x3D; text.split(&#x27;\n&#x27;);

    for (let y &#x3D; 0; y &lt; lines.length; y++) {
      const line &#x3D; lines[y].trim();
      const l: TokenTextLayerLine &#x3D; {
        y: y + 1,
        tokens: []
      };
      let x &#x3D; 0,
        xBeg &#x3D; 0;

      while (x &lt; line.length) {
        if (this.isWhitespace(line.charAt(x))) {
          l.tokens.push(line.substr(xBeg, x - xBeg));
          x++;
          while (x &lt; line.length &amp;&amp; this.isWhitespace(line.charAt(x))) {
            x++;
          }
          xBeg &#x3D; x;
        } else {
          x++;
        }
      }
      if (xBeg &lt; x) {
        l.tokens.push(line.substr(xBeg));
      }
      results.push(l);
    }

    return results;
  }

  /*
   * Rendition: HTML rendering from a base text and a set of fragments locations.
   * Each line in the base text is rendered with p; each token in a line is
   * rendered with its text value, and tokens are separated by space. Layer
   * fragments are rendered inside a span, with an id equal to the fragment location
   * plus a suffix beginning with _, added only for the purpose of ensuring unique
   * IDs in the rendered HTML code. Example:
   * &lt;div&gt;
   *  &lt;p id&#x3D;&quot;y1&quot;&gt;this is line 1.&lt;/p&gt;
   *  &lt;p id&#x3D;&quot;y2&quot;&gt;here&#x27;s a &lt;span id&#x3D;&quot;f2.3_0&quot;&gt;fragment&lt;/span&gt;.&lt;/p&gt;
   * &lt;/div&gt;
   */

  /**
   * Render the opening span for a layer fragment.
   * @param loc location.
   * @param locPortion the index of the token&#x27;s portion (0-N). This is used
   * to build a unique ID for each HTML span rendering a layer fragment.
   * @param sb the target strings array.
   * @param isSelected true if selected.
   */
  private renderOpeningSpan(
    loc: TokenLocation,
    locPortion: number,
    sb: string[],
    isSelected: boolean
  ) {
    sb.push(
      &#x60;&lt;span id&#x3D;&quot;f${loc.toString()}_${locPortion}&quot; class&#x3D;&quot;fr${
        isSelected ? &#x27;fr-sel&#x27; : &#x27;&#x27;
      }&quot;&gt;&#x60;
    );
  }

  /**
   * Render the specified token intersecting the specified end-fragment location.
   * @param pt The point.
   * @param token The token.
   * @param sb The target array.
   */
  private renderTokenAtEnd(pt: TokenPoint, token: string, sb: string[]): void {
    if (pt.at &gt; 0) {
      // ...to]
      sb.push(token.substr(pt.at - 1, pt.run));
      sb.push(&#x27;&lt;/span&gt;&#x27;);
      // ...ken
      if (pt.at - 1 + pt.run &lt; token.length) {
        sb.push(token.substr(pt.at - 1 + pt.run));
      }
    } else {
      // ...token]
      sb.push(token);
      sb.push(&#x27;&lt;/span&gt;&#x27;);
    }
  }

  /**
   * Render the specified token intersecting the specified single-point location.
   * The received token starts and ends a single-token range.
   * @param loc location.
   * @param token token.
   * @param sb target strings array.
   * @param isSelected True if the token is selected.
   */
  private renderTokenAtPointStart(
    loc: TokenLocation,
    token: string,
    sb: string[],
    isSelected: boolean
  ) {
    // 1.token&#x27;s left-part
    if (loc.primary.at &gt; 0) {
      // to...
      sb.push(token.substr(0, loc.primary.at - 1));
    }

    // 2.span: [
    this.renderOpeningSpan(loc, 0, sb, isSelected);

    // 3.token&#x27;s right-part (...ken]/...ke]n or ...token])
    this.renderTokenAtEnd(loc.primary, token, sb);
  }

  /**
   * Render the specified token intersecting the specified range start location.
   * The received token starts a multi-tokens range.
   * @param loc location.
   * @param locPortion the index of the token&#x27;s portion (0-N). This is used
   * to build a unique ID for each HTML span rendering a layer fragment.
   * @param token token.
   * @param sb target strings array.
   * @param isSelected True if the token is selected.
   */
  private renderTokenAtRangeStart(
    loc: TokenLocation,
    token: string,
    sb: string[],
    isSelected: boolean
  ) {
    // 1.token&#x27;s left-part
    if (loc.primary.at &gt; 0) {
      // to...
      sb.push(token.substr(0, loc.primary.at));
    }

    // 2.span: [
    this.renderOpeningSpan(loc, 0, sb, isSelected);

    // 3.token&#x27;s right-part (...ken or ...token)
    if (loc.primary.at &gt; 0) {
      // ...ken
      sb.push(token.substr(loc.primary.at - 1));
    } else {
      // ...token
      sb.push(token);
    }
  }

  private renderTokenAtStart(
    loc: TokenLocation,
    token: string,
    sb: string[],
    isSelected: boolean
  ): boolean {
    if (!loc.secondary) {
      // single
      this.renderTokenAtPointStart(loc, token, sb, isSelected);
      return false;
    } else {
      // range
      this.renderTokenAtRangeStart(loc, token, sb, isSelected);
      return true;
    }
  }

  /**
   * Render to HTML the base text decorated with its layer fragments.
   * @param text The base text.
   * @param locations The locations of all the fragments
   * of the same type to be rendered on top of the base text.
   * @param selectedLoc The optional location of the selected
   * fragment if any. The selected fragment gets decorated with an additional
   * class value.
   */
  public render(
    text: string,
    locations: TokenLocation[],
    selectedLoc: TokenLocation &#x3D; null
  ): string {
    if (!text) {
      return &#x27;&lt;div&gt;&lt;/div&gt;&#x27;;
    }

    // get lines from text
    const sb: string[] &#x3D; [];
    const lines &#x3D; this.getLines(text);
    let loc: TokenLocation &#x3D; null;
    let tokenSelected &#x3D; false;

    if (!locations) {
      locations &#x3D; [];
    }

    // for each line in text
    sb.push(&#x27;&lt;div&gt;&#x27;);
    for (let y &#x3D; 0; y &lt; lines.length; y++) {
      sb.push(&#x60;&lt;p id&#x3D;&quot;y${y + 1}&quot;&gt;&#x60;);

      // reopen a span if continuing a fragment from prev line
      if (loc) {
        this.renderOpeningSpan(loc, y + 1 - loc.primary.y, sb, tokenSelected);
      }

      // for each token in line
      const line &#x3D; lines[y];
      for (let x &#x3D; 0; x &lt; line.tokens.length; x++) {
        // add separator if required
        if (x &gt; 0) {
          sb.push(&#x27; &#x27;);
        }

        const token &#x3D; line.tokens[x];

        // if inside a fragment, check if this token is the last
        if (loc &amp;&amp; loc.secondary) {
          if (loc.secondary.y &#x3D;&#x3D;&#x3D; y + 1 &amp;&amp; loc.secondary.x &#x3D;&#x3D;&#x3D; x + 1) {
            this.renderTokenAtEnd(loc.secondary, token, sb);
            loc &#x3D; null;
          } else {
            sb.push(token);
          }
        } else {
          // else, check if this token starts a fragment
          loc &#x3D; locations.find(l &#x3D;&gt; {
            return l.primary.y &#x3D;&#x3D;&#x3D; y + 1 &amp;&amp; l.primary.x &#x3D;&#x3D;&#x3D; x + 1;
          });
          if (loc) {
            tokenSelected &#x3D; selectedLoc ? loc.overlaps(selectedLoc) : false;
            if (!this.renderTokenAtStart(loc, token, sb, tokenSelected)) {
              loc &#x3D; null;
            }
          } else {
            sb.push(token);
          }
        }
      }

      // close a span if pending at p end
      if (loc) {
        sb.push(&#x27;&lt;/span&gt;&#x27;);
      }
      sb.push(&#x27;&lt;/p&gt;&#x27;);
    }
    sb.push(&#x27;&lt;/div&gt;&#x27;);
    return sb.join(&#x27;&#x27;);
  }

  /*
    Location: starting from user selection on a rendered text, get the corresponding
    layer fragment location. This differs according to the purpose of the location
    to be got: if getting a location for an existing fragment, at least 1 decorated
    text (span) should be included in the selection, which does not require to be
    exact; if getting a location for a new fragment, no decorated text (span) can be
    included in the selection (two fragments in the same layer can never overlap),
    which must be exact.
  */

  /**
   * Get the Y bounds from the specified selection.
   * @param range The selection range.
   * @param forNew True if getting bounds for a new fragment.
   * @returns Array where [0]&#x3D;min and [1]&#x3D;max.
   */
  private getYBoundsFromRange(range: SelectedRange, forNew: boolean): number[] {
    let p: Element &#x3D; null;

    switch (range.commonAncestorContainer.nodeType) {
      case Node.TEXT_NODE:
        // single-p selection, parent&#x3D;p
        p &#x3D; range.commonAncestorContainer.parentElement;
        if (forNew &amp;&amp; (p.nodeName !&#x3D;&#x3D; &#x27;P&#x27; || !p.hasAttribute(&#x27;id&#x27;))) {
          return null;
        }
        if (p.nodeName &#x3D;&#x3D;&#x3D; &#x27;SPAN&#x27;) {
          p &#x3D; p.parentElement;
        }
        const y &#x3D; parseInt(p.getAttribute(&#x27;id&#x27;).substr(1), 10);
        return [y, y];

      case Node.ELEMENT_NODE:
        // div only is allowed; in this case, it&#x27;s a multi-p range
        if (range.commonAncestorContainer.nodeName !&#x3D;&#x3D; &#x27;DIV&#x27;) {
          return null;
        }
        let yMin &#x3D; 0,
          yMax &#x3D; 0;
        let inside &#x3D; false;
        for (
          let i &#x3D; 0;
          i &lt; range.commonAncestorContainer.childNodes.length;
          i++
        ) {
          const child &#x3D; range.commonAncestorContainer.childNodes[i];
          if (child.nodeType !&#x3D;&#x3D; Node.ELEMENT_NODE || child.nodeName !&#x3D;&#x3D; &#x27;P&#x27;) {
            continue;
          }
          // check if we&#x27;re entering the start-p
          if (!inside &amp;&amp; child.contains(range.startContainer)) {
            inside &#x3D; true;
          }
          // no (span) child is allowed in p for new fragments
          if (inside &amp;&amp; forNew &amp;&amp; (&lt;Element&gt;child).firstElementChild) {
            return null;
          }
          // collect y if inside
          if (inside) {
            const iy &#x3D; parseInt(
              (&lt;Element&gt;child).getAttribute(&#x27;id&#x27;).substr(1),
              10
            );
            if (!yMin || iy &lt; yMin) {
              yMin &#x3D; iy;
            }
            if (!yMax || iy &gt; yMax) {
              yMax &#x3D; iy;
            }
            // check if we have exited the last p
            if (child.contains(range.endContainer)) {
              break;
            }
          }
        }
        return [yMin, yMax];
    }
  }

  private locatePrevSpace(line: string, index: number): number {
    while (index &gt; -1 &amp;&amp; line.charAt(index) !&#x3D;&#x3D; &#x27; &#x27;) {
      index--;
    }
    return index;
  }

  private locateNextSpace(line: string, index: number): number {
    while (index &lt; line.length &amp;&amp; line.charAt(index) !&#x3D;&#x3D; &#x27; &#x27;) {
      index++;
    }
    return index &#x3D;&#x3D;&#x3D; line.length ? -1 : index;
  }

  /**
   * Get the bounds of the token any character of which is indexed
   * by index.
   * @param line The text line.
   * @param index The index to the text line to start from.
   * @returns Bounds where [0]&#x3D;index of the first character of the token,
   * and [1]&#x3D;index of the character past the token&#x27;s last character;
   * or null if index was not valid.
   */
  private getTokenBounds(line: string, index: number): number[] {
    if (line.charAt(index) &#x3D;&#x3D;&#x3D; &#x27; &#x27;) {
      return null;
    }
    let start &#x3D; this.locatePrevSpace(line, index);
    if (start &#x3D;&#x3D;&#x3D; -1) {
      start &#x3D; 0;
    } else {
      start++;
    }
    let end &#x3D; this.locateNextSpace(line, index);
    if (end &#x3D;&#x3D;&#x3D; -1) {
      end &#x3D; line.length;
    }
    return [start, end];
  }

  private getAdjustedSelectionBounds(
    selStart: number,
    selEnd: number,
    line: string
  ): number[] {
    // corner case: if on space, move to right
    if (line.charAt(selStart) &#x3D;&#x3D;&#x3D; &#x27; &#x27;) {
      selStart++;
    }
    // corner case: if included trailing space, move to left
    if (selEnd &gt; 0 &amp;&amp; line.charAt(selEnd - 1) &#x3D;&#x3D;&#x3D; &#x27; &#x27;) {
      selEnd--;
    }
    return [selStart, selEnd];
  }

  /**
   * Get the start coordinates for the selected range and line.
   * @param range The selected range.
   * @param line The reference text line.
   */
  private getStartCoordsFromRange(
    selStart: number,
    selEnd: number,
    line: string
  ): TextCoords {
    // get adjusted selection bounds
    const selBounds &#x3D; this.getAdjustedSelectionBounds(selStart, selEnd, line);
    // get the bounds of the first selected token
    const tokBounds &#x3D; this.getTokenBounds(line, selBounds[0]);

    // calculate x by counting the tokens before the target token
    let x &#x3D; 1;
    let j &#x3D; tokBounds[0] - 1;
    while (j &gt; -1) {
      if (line.charAt(j) &#x3D;&#x3D;&#x3D; &#x27; &#x27;) {
        x++;
      }
      j--;
    }

    // calculate at,run only when either of these is true:
    // (a) selection starts past the 1st char of the token (al[pha);
    // (b) selection ends before the last char of the token (al]pha);
    // run is calculated only if (b) is true.
    let at &#x3D; 0,
      run &#x3D; 0;
    if (selBounds[0] &gt; tokBounds[0] || selBounds[1] &lt; tokBounds[1]) {
      at &#x3D; 1 + selBounds[0] - tokBounds[0];
      run &#x3D;
        selBounds[1] &lt; tokBounds[1]
          ? selBounds[1] - tokBounds[0] // al]pha
          : tokBounds[1] - selBounds[0]; // alpha]
    }

    return {
      y: 0,
      x: x,
      at: at,
      run: run
    };
  }

  private getEndCoordsFromRange(
    selStart: number,
    selEnd: number,
    line: string
  ): TextCoords {
    // get adjusted selection bounds
    const selBounds &#x3D; this.getAdjustedSelectionBounds(selStart, selEnd, line);
    // get the bounds of the last selected token
    const tokBounds &#x3D; this.getTokenBounds(line, selBounds[1] - 1);

    // calculate x by counting the tokens before the target token
    let x &#x3D; 1;
    let j &#x3D; selBounds[1] - 1;
    while (j &gt; -1) {
      if (line.charAt(j) &#x3D;&#x3D;&#x3D; &#x27; &#x27;) {
        x++;
      }
      j--;
    }

    // calculate at,run only when selection ends before the 1st char of the token
    // (al]pha); run is calculated only if at is calculated.
    let at &#x3D; 0, run &#x3D; 0;
    if (selBounds[1] &lt; tokBounds[1]) {
      at &#x3D; selBounds[0] &gt; tokBounds[0] ? 1 + selBounds[0] - tokBounds[0] : 1;
      run &#x3D; selBounds[1] - tokBounds[0];
    }

    return {
      y: 0,
      x: x,
      at: at,
      run: run
    };
  }

  private getSpanLocFromId(id: string): TokenLocation {
    if (!id) {
      return null;
    }
    const r &#x3D; new RegExp(&#x27;^f([-\\d+.@x]+)&#x27;, &#x27;g&#x27;);
    const m &#x3D; r.exec(id);
    if (!m) {
      return null;
    }
    return TokenLocation.parse(m[1]);
  }

  private visitNodes(node: Node, visitor: (current: Node) &#x3D;&gt; boolean) {
    if (!visitor(node)) {
      return;
    }
    if (node.nodeType &#x3D;&#x3D;&#x3D; Node.ELEMENT_NODE) {
      for (let i &#x3D; 0; i &lt; node.childNodes.length; i++) {
        const child &#x3D; node.childNodes[i];
        this.visitNodes(child, visitor);
      }
    }
  }

  private findFirstDescendantSpan(range: SelectedRange): Element {
    let inside &#x3D; false;
    let span &#x3D; null;

    this.visitNodes(range.commonAncestorContainer, current &#x3D;&gt; {
      if (current &#x3D;&#x3D;&#x3D; range.startContainer) {
        inside &#x3D; true;
      }
      if (
        current.nodeType &#x3D;&#x3D;&#x3D; Node.ELEMENT_NODE &amp;&amp;
        current.nodeName &#x3D;&#x3D;&#x3D; &#x27;SPAN&#x27;
      ) {
        span &#x3D; current;
        return false;
      }
      if (current &#x3D;&#x3D;&#x3D; range.endContainer) {
        inside &#x3D; false;
      }
      return true;
    });

    return span;
  }

  /**
   * Get the location corresponding to the user selection,
   * for editing the first fragment included in it.
   * @param range The selected range. You can get it from the
   * current selection using getSelectedRange().
   * @returns The token location or null.
   */
  public getSelectedLocationForEdit(range: SelectedRange): TokenLocation {
    if (!range) {
      return null;
    }
    // just find the first descendant span in selection
    let span: Element &#x3D; null;
    switch (range.commonAncestorContainer.nodeType) {
      case Node.ELEMENT_NODE:
        span &#x3D; &lt;Element&gt;range.commonAncestorContainer;
        if (span.nodeName !&#x3D;&#x3D; &#x27;SPAN&#x27;) {
          span &#x3D; this.findFirstDescendantSpan(range);
        }
        break;
      case Node.TEXT_NODE:
        span &#x3D; range.commonAncestorContainer.parentElement;
        if (
          span &amp;&amp;
          (span.nodeType !&#x3D;&#x3D; Node.ELEMENT_NODE || span.nodeName !&#x3D;&#x3D; &#x27;SPAN&#x27;)
        ) {
          span &#x3D; null;
        }
        break;
    }

    return span ? this.getSpanLocFromId(span.getAttribute(&#x27;id&#x27;)) : null;
  }

  private textLineToString(line: TokenTextLayerLine) {
    if (!line || !line.tokens) {
      return &#x27;&#x27;;
    }
    return line.tokens.join(&#x27; &#x27;);
  }

  /**
   * Get the location corresponding to the user selection,
   * for adding a new fragment with the same extension.
   * @param range The selected range. You can get it from the
   * current selection using getSelectedRange().
   * @param text The full base text.
   * @returns TokenLocation The token location or null.
   */
  public getSelectedLocationForNew(
    range: SelectedRange,
    text: string
  ): TokenLocation {
    if (!range) {
      return null;
    }
    // get y bounds (min, max; equal if single-line)
    const yBounds &#x3D; this.getYBoundsFromRange(range, true);
    if (!yBounds) {
      return null;
    }

    // get lines and calculate start/end coords
    const lines &#x3D; this.getLines(text);
    const startLine &#x3D; this.textLineToString(lines[yBounds[0] - 1]);
    const endLine &#x3D; this.textLineToString(lines[yBounds[1] - 1]);
    const startLineEndOffset &#x3D;
      yBounds[0] !&#x3D;&#x3D; yBounds[1] ? endLine.length : range.endOffset;
    const start &#x3D; this.getStartCoordsFromRange(
      range.startOffset,
      startLineEndOffset,
      startLine
    );
    start.y &#x3D; yBounds[0];

    const end &#x3D; this.getEndCoordsFromRange(
      range.startOffset,
      range.endOffset,
      endLine
    );
    end.y &#x3D; yBounds[1];
    const singleLine &#x3D; start.y &#x3D;&#x3D;&#x3D; end.y;
    const singleToken &#x3D; singleLine &amp;&amp; start.x &#x3D;&#x3D;&#x3D; end.x;

    const sb &#x3D; [];
    // start: y.x
    sb.push(&#x60;${start.y}.${start.x}&#x60;);

    if (singleToken) {
      // single token: check for at,run
      if (start.at) {
        sb.push(&#x60;@${start.at}&#x60;);
        if (start.run &gt; 1) {
          sb.push(&#x60;x${start.run}&#x60;);
        }
      }
    } else {
      // not a single token
      // first token
      if (start.at) {
        sb.push(&#x60;@${start.at}x${start.run}&#x60;);
      }
      // last token
      sb.push(&#x60;-${end.y}.${end.x}&#x60;);
      if (end.at) {
        sb.push(&#x60;@1x${end.run}&#x60;);
      }
    }
    return TokenLocation.parse(sb.join(&#x27;&#x27;));
  }

  /**
   * Get the currently selected range in the browser&#x27;s document.
   * This uses the rangy library.
   */
  public getSelectedRange(): Range {
    const sel &#x3D; rangy.getSelection();
    if (sel.isCollapsed) {
      return null;
    }
    return sel.getRangeAt(0);
  }
}
</code></pre>
    </div>
</div>


                   




                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> result-matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'SelectedRange.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>
       <!-- Required to polyfill modern browsers as code is ES5 for IE... -->
       <script src="../js/libs/custom-elements-es5-adapter.js" charset="utf-8" defer></script>
       <script src="../js/menu-wc.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
